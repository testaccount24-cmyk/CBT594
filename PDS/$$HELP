./ ADD NAME=DADMIN   0100-02273-02273-0938-00055-00055-00000-GARDINR
Administration

  You can make DDF available to others both on your local machine
  and further afield.

  Local use

  Dissemination is done like this on one MVS image:

     * copy the command UTCDSM5 to a central command library
     * ensure that the DDFLIB dataset is read-available to all
       potential DDF users

  That's it!

  You can keep track of what people think of DDF, if you want to.
  This is done by means of the survey dataset. If the DDFLIB
  dataset is:

          QUAL1.QUAL2.DDFLIB

  then you can create a new dataset

          QUAL1.QUAL2.SURVEY

  which DDF will look for. It should be an FB(80) PDS or PDS/E.
  If it's a PDS it should have plenty of directory space because
  DDF will generate one member for each DDF user. All DDF users
  must have update access to the survey dataset and you should
  copy the member ZTEMPLAT from DDFLIB to it.

        Every so often, DDF will display the ZTEMPLAT member to
  each user, asking them to fill in what they think of the
  product. DDF will then save it using the Userid as member name.
  DDF will also update the Userid's member on the survey each
  time they use the product; it will add one to the Mod field in
  the ISPF stats. Thus when you take a member list of the survey
  dataset, if you

          SORT CHANGED

  you will see the last people to enter their views about DDF,
  which you can then look at, and if you

          SORT MOD

  you can see who uses it most and how much.

  Notify friends

  If you like DDF, please feel free to tell your friends. You can
  either point out the web site, or if they have no internet
  access you can e-mail them and attach the Zip file from the
  site, telling them to un-zip and open their browser on file
  dfr01.htm.
./ ADD NAME=DALLOC   0100-02273-02273-0938-00039-00039-00000-GARDINR
Allocated datasets

  You can type LA on the command line, which will generate a list
  of all the datasets allocated to your session giving the DDname
  and associated dataset(s) for each.

  -------------------------- List of allocated datasets ---  ROW 1
   Command ===>

  C  Member   DDname   Dataset name                   Stats
              ISPMUSR  USER01.USER.CLIST
              ISPSUSR  USER01.USER.CLIST
              ISPPLIB  SYS3.PLIB
                       SYS1.PLIB

  You can now issue commands

     L ddname
     F membername ddname

  The L command brings the first line of the concatenation for
  <ddname> to the top of the display, so that you can see what is
  in it. The F command finds <membername> within <ddname>,
  showing all instances, so that you can see where a command,
  panel, message or whatever is coming from. When the members are
  found, their ISPF stats are shown on the screen; so the
  response to F UTCDSM5 SYSPROC might look like this:

  C Member   DDname   Dataset name              Stats
             SYSPROC  SYS3.CLIB
                      SYS4.CLIB
                      SYS1.CLIB
    UTCDSM5           USER01.USER.CLIST        01.34 95/08/18 12:05 USER01


  Under the C heading you can enter e b or v, which will Edit
  Browse or View the dataset, producing a member list. If the
  member has been put in after using F to find them, that member
  will be edited.
./ ADD NAME=DBRED    0100-02273-02273-0938-00024-00024-00000-GARDINR
Browse and Edit

  Looking at PDSs is done with these commands under the CMD
  heading.

  E    If a member name is given under Member heading, edit it.
       If not, create and edit it.
  B    If a member is given, browse it. If it's not found, create
       a member list using the member given as a pattern. If no
       member is specified, produce a list of all members.
  ML   Produce a full member list whether or not a member is
       specified.
  V    As for B, but instead of Browsing a member, view it.

  When you edit, broswse or view a member, DDF will produce a
  message giving the user, date and time of the last edit. If you
  are editing and the user was not you, the beep sounds. This
  helps to alert you if someone else has updated something you
  are going to update.

       These commands can also be used on sequential files, but
  not VSAM or other data that ISPF cannot process. The member
  field is ignored for sequential files - it's not an error to
  have a member name, it's just not checked or used.
./ ADD NAME=DDCLAIM  0100-02273-02273-0938-00026-00026-00000-GARDINR

  Copyright (c) 2000 Roy Gardiner

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation
  files (the ``Software''), to use and change the Software
  without restriction, subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  You may not, by way of trade, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, or
  technical support of the Software, or training in the use of the
  Software.

  THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY
  KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
  AND NONINFRINGEMENT.  IN NO EVENT SHALL ROY GARDINER BE LIABLE
  FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OF THE SOFTWARE.

  -------------------------------------------------------------------
                         Last updated: 27 Jan 2001
./ ADD NAME=DINSTALL 0100-02273-02273-0938-00054-00054-00000-GARDINR
Installation

 DDF can be downloaded from two sources:

 Binary file
      which holds DDF in a TSO XMIT file in uncompressed format.
      Download this to your PC, calling it ddflib.bin
 Zip file
      which holds the XMIT format file plus the documentation
      pages from the web site in compressed form. Download this
      to your PC and unzip it. You can view this documentation
      from your PC now, by opening file 'dfr01.htm' in your
      browser. This will speed up viewing it because all the
      files are now local.

 Upload the DDF components to your mainframe

 All the DDF components are held in ddflib.bin, which should be
 uploaded to the mainframe. The transfer must be binary (no CRLF
 or ASCII translation) and the target dataset should be LRECL=80
 and record format of fixed. This is very important! The RECEIVE
 command requires that the XMIT files be Lrecl=80 and fixed. It's
 often best to pre-allocate this dataset before doing the upload.

 On TSO, RECEIVE INDATASET(name)

 When prompted by message "INMR906A Enter restore parameters or
 'DELETE' or 'END' +": respond

 DA('hlq1.hlq2.DDFLIB')

 The hlq1 will typically be your userid, hlq2 is your choice

 Install the command

 Copy UTCDSM5 (the DDF controlling exec) to your command or exec
 library, and edit it as follows:

000027  /**********************************************************************/
000028                               /* Editable variables -- start           */
000029    genHLQ           = "hlq1"
000030    genLev2Q         = "hlq2"

 Change the strings to the first and second level qualifiers you
 have chosen.

 Start

 Start by typing

         TSO UTCDSM5

 on any ISPF command line; if the DDF main panel displays,
 installation is complete.  Proceed to Getting started.
./ ADD NAME=DINTRO   0100-02273-02273-0938-00057-00057-00000-GARDINR
Introduction

  The idea of DDF is to speed up many of the normal jobs in ISPF
  by eliminating the need to remember and then type dataset names
  all the time.

  DDF keeps a list of datasets, which you enter under the Text
  heading above. Names can be in any order. Actions are entered
  under the Cmd heading and include commands to

     * edit a dataset (or member)
     * browse a dataset (or member)
     * display and edit member stats
     * compare members
     * copy a member from one dataset to another (optionally
       changing name)
     * compare and merge members
     * find versions of members across many datasets
     * submit jobs
     * access ISPF functions including 3.1, 3.2, 3.3, 3.4, 3.14
       (search for strings)
     * produce member list and then within member list:

          o submit batch job
          o browse member
          o edit member
          o rename member
          o delete member
          o execute member.

  What is DDF?

  DDF is a Rexx exec and some ISPF panels, skeletons and
  messages. There is no Assembler and no need to complile
  anything. There are no tricks or dodges; all DDF functions are
  standard ISPF which you can see (and modify if you need to) in
  the code.

       You do not need to be a systems programmer to install DDF;
  anyone with modest knowledge of ISPF can set it up for personal
  use, or for use by more than one person. DDF does not interfere
  with your ISPF environment beyond requiring one exec to be
  copied to a suitable command library. All other DDF libraries
  remain separate from and therefore independent of your standard
  session, and indeed are only available whilst DDF is running -
  DDF uses LIBDEF to gain access to them.

  Who uses DDF?

  When DDF is made widely available, experience shows that that
  up to 10% of a typical TSO/ISPF user population will use it
  every day; some of these will use DDF as their standard front
  screen, rather than having an ISPF main menu. The main users
  seem generally to be to be development people rather than
  systems programmers; the latter have often written any number
  of shortcuts and tools for themselves and have their working
  environments tailored perfectly to suit them.
./ ADD NAME=DLINES   0100-02273-02273-0938-00023-00023-00000-GARDINR
Order of lines

  The order of display can be altered by several prefix commands
  entered under the CMD heading

  In   Insert n lines. If n is omitted then 1 blank line is added
  Rn   Repeat n times. If n is omitted then the line is repeated
       once.
  C    Copy line. Used in conjunction with A or B4
  A    Used with Copy or Move, where the line goes After the
       specified line
  B4   Use with Copy or Move, where the line goes Before the
       specified line.
             B4 is used to avoid confusion with the much more
       commonly used B for Browse prefix command
  D    Delete line
  X    Exclude line from the display

  See also the usage of the Show List and Show headings, which
  enable you to group lines together (e.g. for groups of datasets
  in the same project) and to control where they are in the list
  and whether or not they are displayed. These enable you to keep
  the most often used datasets at the top of the list.
./ ADD NAME=DMCMP    0100-02273-02273-0938-00084-00084-00000-GARDINR
Member compare

 You can invoke a standard SuperC compare like this:

 Cmd  Member   Text                     Description   Show
 cpn  FRED     USERID.QUAL2.QUAL3.QUAL4
 cpo  BILL     OTHERID.SOME.DATA.OR.OTHER

 Where the commands mean Compare New and Compare Old. The member
 with cpn against it is treated as the 'new' item, the other as
 the 'old' item. If the members to be compared have the same
 name, you need only enter it once, next to either of the
 commands. You do not have to enter the commands in any order,
 and you can enter one command, do other things (e.g. scrolling
 up and down), then enter the other.

       You will be placed in browse of a temporary dataset
 containing the result of the comparison. The output report might
 look like this:

 BROWSE -  USER01.XMTEMP.D9940610.T51752.SUPERC1 - LINE 000 COL001 080
 COMMAND ===>                                       SCROLL ===> HALF
 *************************** TOP OF DATA  ***************************
 SUPERC - MVS/PDF FILE/LINE/WORD/BYTE/SFOR COMPARE UTILITY - V2.12
 NEW: USER01.USER.CLIST(FRED)                   OLD:USER01.USER.CLIST(BILL)
  ID       SOURCE LINES
      ----+----1----+----2----+----3----+----4----+----5----+----6----
  I -      ISPEXEC VPUT (XXX) PROFILE
  D -      ISPEXEC VPUT (XXX) SHARED
  I -         ISPEXEC VPUT (XXX) PROFILE
  D -         ISPEXEC VPUT (XXX) SHARED

 The report is SuperC standard; full details of the SuperC
 listings are available in the ISPF/PDF Guide supplied by IBM.

 extended compare

 The extended compare can be used to:

    * change compare parameters, such as the compare columns
    * merge two versions of an item into a third, merged version
    * carry out a special logical comparison, which is used to
      analyse the change control status of two items which have
      been edited in a way defined by DDF.

 The extended compare is invoked by using NEW/OLD prefix commands
 instead of CPN/CPO. Instead of going directly to SuperC, the
 extended compare panel is displayed:

  -------------------------- SuperC extended --------------------
  Command ===>

     1  Compare         - Compare using SuperC
     2  Merge           - Merge using SuperC
     3  Logical compare - Compare only the change control areas

     New ===> USER01..USER.CLIST                       <
  Member ===> FRED    <
     Old ===> USER02..USER.CLIST                       <
  Member ===> FRED02   <

   Merge ===>                                          <
  Member ===>          <
  (Dataset names should be fully qualified, without quotes)
    ===> 2 < Leftmost compare column (zero for full width compare)
    ===> 72 < Rightmost compare column

 1: Compare

 This will compare the New and Old files and produce a report
 which is displayed to the user in Browse mode. This is the same
 as CPN/CPO except that you can select column numbers to pass to
 SuperC. Columns outside the range will be ignored during the
 compare. Note that if you are comparing COBOL programs, you will
 probably want to exclude the sequence number columns 1-6 and
 73-80, i.e. to select columns 7 to 72.

 2: Merge

 You can merge the files into a new file and be placed into Edit
 of the merged result. If you attempt a merge and the target file
 already exists, you are informed of this and the merge is not
 done. Merge uses SuperC to combine the two files. There is a
 full explanation of how merging works.
./ ADD NAME=DMCOPY   0100-02273-02273-0938-00032-00032-00000-GARDINR
Member copy and move

  You can copy between datasets like this:

  Cmd Member   Text                     Description   Show
  CO  FRED     USERID.QUAL2.QUAL3.QUAL4
  TO  BILL     OTHERID.SOME.DATA.OR.OTHER

  The commands shown above will Copy the member FRED To the
  member BILL on the target dataset. If you want to copy or move
  without changing the member name, you can leave the member name
  blank on the TO and OV lines. The command combinations that can
  be used are as follows (choose one from the left column and one
  from the right):

                       target member name. If the member already
   co  copy member to  exists, it is not overwritten

   mo  move member ov  target member name. Any existing member is
                       overwritten

  Note that the same dataset can appear as many times as you like
  on a DDF list. If you use the same dataset name with CO/MO and
  TO/OV:

     * Using the same member and same dataset is not an error,
       but also is not sensible!
     * A MO/TO operation using the same dataset names and
       different member is equivalent to renaming the member;
       MO/OV will over-write any existing member.
     * CO/TO or CO/OV creates a new copy, with or without
       over-writing the target, respectively.
./ ADD NAME=DMLIST   0100-02273-02273-0938-00048-00048-00000-GARDINR
Member list

 You can get a member list by typing B or ML under the CMD
 heading; B will use the member name as a pattern (if the name is
 not found; if it is found, it will be browsed directly), ML will
 produce a full member list, which might look like this:

 MEMBER LIST -- USER01.USER.CLIST --DDF List B ------------ ROW 00001 OF 00004
  COMMAND ===>                                                  SCROLL ===>PAGE
             NAME                 VV.MM     CHANGED     SIZE  INIT   MOD   ID
            #PDF                  01.08 95/09/29 16:31    48    32     0 USER01
            #PDFB                 01.00 95/06/28 09:17    43    43     0 USER01
            #PDFRX                01.08 90/06/13 10:24    36    25     0 USER01
            #PDFX                 01.00 95/09/29 16:29    47    47     0 USER01
            **END**

 When you get a member list (and you may often type in a member
 name you know does not exist in order to get one) then you can
 use these commands in the prefix area to the left of the member
 name:

 b    browse the member
 delete
      delete the member. For obvious reasons there is no
      abbreviation for this command.
 e    edit the member
 exec
      execute this member, if it is a Clist or Rexx exec. If you
      issue exec against something not a Clist or Rexx exec, you
      will get an error message
 r    rename the member to a new name, which you type in next to
      the old one in the column provided. The old member name
      stays in the list, with the new member name next to it, as
      an audit trail, until you quit the member list.
 sub  submit the member to batch for execution. If it is not a
      valid JCL job, you will get an error message.

 Note that at present there is no = command like the one in 3.4.

 On the main command line, you can type these commands:

 b membername
      Browse the membername. The member must exist, but need not
      be on the current member list displayed
 e membername
      Edit the membername. The member need not exist, nor need it
      be on the current member list displayed. If it does not
      exist, a new member is created.
./ ADD NAME=DMMRG    0100-02273-02273-0938-00257-00257-00000-GARDINR
SuperC Merge

 SuperC can merge two files together to produce a third, combined
 version.  The merged file contains control information to allow
 the user how to ensure that the final version is a correct
 combination of the two input versions.

 Two sample files are shown here, with a third which is the
 result of the SuperC merge process. A line by line guide is then
 given as to what the control information means.

 Merge file (old)
     LINE 1
     LINE 2
     LINE 3 1
     LINE 4 IS DELETED ON THE NEW FILE
     LINE 5
     LINE 6
     LINE 7
     LINE 8
     LINE 9
     LINE 10
     LINE 11 WHICH IS DELETED ON THE NEW FILE
     LINE 12 NOW THE LINE NUMBERS MATCH AGAIN
     LINE 13
     LINE 14
     LINE 15
 Merge file (new)
     LINE 1
     LINE  2
     LINE 3
     LINE 5
     LINE 6 IS CHANGED ON THE NEW FILE
     LINE 6A IS INSERTED AFTER A CHANGED LINE
     LINE 7
     LINE 7A WHICH IS INSERTED ON THE NEW FILE
     LINE 8
     LINE 9 IS NOW ON LINE 10 BUT IDENTIFIED AS A CHANGE
     LINE 10
     LINE 12 NOW THE LINE NUMBERS MATCH AGAIN
     LINE 13
     LINE 14

 Merging these two files will create an output file like this,
 with SuperC control statements inserted:

 Merged result
 *HDR1  USER01.USER.CLISTB(COM2)
 *HDR2  USER01.USER.CLISTB(COM1)
 *M-    MAT#=  1      N-REF#=000001 O-REF#=000001
     LINE 1
 *I-RF  INS#=  1      N-REF#=000002 O-REF#=000002
     LINE  2
 *D-RF  DEL#=  1      N-REF#=000002 O-REF#=000002
     LINE 2
 *M-    MAT#=  1      N-REF#=000003 O-REF#=000003
     LINE 3
 *D-    DEL#=  1      N-REF#=000003 O-REF#=000004
     LINE 4 IS DELETED ON THE NEW FILE
 *M-    MAT#=  1      N-REF#=000004 O-REF#=000005
     LINE 5
 *I-RP  INS#=  2      N-REF#=000005 O-REF#=000006
     LINE 6 IS CHANGED ON THE NEW FILE
     LINE 6A IS INSERTED AFTER A CHANGED LINE
 *D-RP  DEL#=  1      N-REF#=000005 O-REF#=000006
     LINE 6
 *M-    MAT#=  1      N-REF#=000007 O-REF#=000007
     LINE 7
 *I-    INS#=  1      N-REF#=000008 O-REF#=000007
     LINE 7A WHICH IS INSERTED ON THE NEW FILE
 *M-    MAT#=  1      N-REF#=000009 O-REF#=000008
     LINE 8
 *I-RP  INS#=  1      N-REF#=000010 O-REF#=000009
     LINE 9 IS NOW ON LINE 10 BUT IDENTIFIED AS A CHANGE
 *D-RP  DEL#=  1      N-REF#=000010 O-REF#=000009
     LINE 9
 *M-    MAT#=  1      N-REF#=000011 O-REF#=000010
     LINE 10
 *D-    DEL#=  1      N-REF#=000011 O-REF#=000011
     LINE 11 WHICH IS DELETED ON THE NEW FILE
 *M-    MAT#=  3      N-REF#=000012 O-REF#=000012
     LINE 12 NOW THE LINE NUMBERS MATCH AGAIN
     LINE 13
     LINE 14
 *D-    DEL#=  1      N-REF#=000014 O-REF#=000015
     LINE 15

 SuperC combines the files where no differences are found. Where
 differences are found, it puts lines from both files into the
 output, with control lines to say what it has done. You then
 delete the control lines plus those lines you do not want - i.e.
 from either the old or new file.  The control lines start in
 column 1 with an asterisk, followed by the control information.
 Note that the legend

        *****SUPERC CHANGE HEADER*****

 normally appears on the right on each control line. These have
 been edited out of the illustration to simplify it. The possible
 SuperC control codes are:.

      *HDR1
      *HDR2
      *D-
      *D-RF
      *D-RP
      *I-
      *I-RF
      *I-RP
      *M-

 Explanation of SuperC merge file

 SuperC identifies reformatted, changed, deleted, inserted and
 matched lines: the merged file contains

    * control data
    * one copy of each matched line
    * alternative copies of the different lines from both files
      so you can choose which you want.

 Each control line from the merged file is shown below, with a
 recommended action where this is appropriate.

       SuperC does not base its comparsions on line numbers, but
 on matching the data. It is not confused by line deletions or
 insertions, but can identify them even when line numbers have
 changed. This means that you will not get 'cascading', where one
 small difference produces many mismatch messages. You will see
 this in the explanation below.

       The HDR control words identify the two datasets that were
 merged

  *HDR1  USER01.USER.CLISTB(COM2)
  *HDR2  USER01.USER.CLISTB(COM1)

 *HDR1 identifies the NEW version, *HDR2 identifies the OLD version.

 Recommended: delete both lines

 You may want to delay doing the deletion until after completing
 the actions outlined below, so that you can remind yourself
 which version is the New and which the Old.

 *M    MAT#=  1      N-REF#=000001 O-REF#=000001

 shows data lines that are the same on both files *M shows that
 matched lines have been found. MAT# shows how many matched lines
 there are. N-REF# and O-REF# are the line numbers in the new and
 old files, respectively, where the match was found. The data
 lines follow the *M line.

 Recommended: delete the *M header line.

 *I-RF  INS#=  1      N-REF#=000002 O-REF#=000002
 ...new file data lines
 *D-RF  DEL#=  1      N-REF#=000002 O-REF#=000002
 ...old file data lines

 *I-RF shows that some lines have been reformatted on the new
 file. INS# is the number of reformatted lines. The new lines
 follow the *I-RF line.

 *D-RF is the header for the reformatted lines from the old file.
 DEL# is the number of reformatted lines. The old lines follow
 the *D-RF line.

 Recommended: Decide which set of reformatted lines you want and
 delete the others, then delete the SuperC control lines

    *M-    MAT#=  1      N-REF#=000003 O-REF#=000003

 *M indicates matched lines, MAT# shows how many. N-REF# and
 O-REF# are the line numbers in the new and old files. The data
 lines follow the *M line.

 Recommended: delete the *M header line.

 *D-    DEL#=  1      N-REF#=000003 O-REF#=000004 ...old file deleted lines

 *D shows that lines have been deleted from the old file. DEL# is
 the number of deleted lines.

 Recommended: delete the lines if they are not required in the
 new file, then delete the control line.

 *M-    MAT#=  1      N-REF#=000004 O-REF#=000005

 *M indicates matched lines, MAT# shows how many. N-REF# and
 O-REF# are the line numbers in the new and old files. The data
 lines follow the *M line.

 Recommended: delete the *M header line.

 *I-RP  INS#=  2      N-REF#=000005 O-REF#=000006
 ....lines from the new file
 *D-RP  DEL#=  1      N-REF#=000005 O-REF#=000006
 ....lines from the old file

 *I-RP is used where lines are replaced rather than reformatted.
 It is therefore much more common that *I-RF and *D-RF. INS# is
 the number of new lines. The new lines follow the *I-RP line.
 *D-RP is the header for the deleted lines from the old file.
 DEL# is the number of deleted lines. The old lines follow the
 *D-RF line.

 Recommended: select which set of lines you want, delete the
 other set and delete the control line

 *M-    MAT#=  1      N-REF#=000007 O-REF#=000007

 *M indicates matched lines, MAT# shows how many. N-REF# and
 O-REF# are the line numbers in the new and old files. The data
 lines follow the *M line.

 Recommended: delete the *M header line.

 *I-    INS#=  1      N-REF#=000008 O-REF#=000007

 *I- shows lines inseted on the new file. INS# is the number of
 new lines.

 Recommended: decide whether you want the lines, delete them if
 not, then delete the control line.

 *M-    MAT#=  1      N-REF#=000009 O-REF#=000008

 *M indicates matched lines, MAT# shows how many. N-REF# and
 O-REF# are the line numbers in the new and old files. The data
 lines follow the *M line.

 Recommended: delete the *M header line.

 *I-RP  INS#=  1      N-REF#=000010 O-REF#=000009
 *D-RP  DEL#=  1      N-REF#=000010 O-REF#=000009

 This illustrates that line numbers need not be the same for a
 changed line to be identified.

 *M-    MAT#=  1      N-REF#=000011 O-REF#=000010

 Recommended: as always, to delete the matched lines header

 *D-    DEL#=  1      N-REF#=000011 O-REF#=000011

 Recommended: decide if the deleted lines are needed or not,
 delete them as appropriate, then delete the control line.

  *M-    MAT#=  3      N-REF#=000012 O-REF#=000012

 Recommended: as always, to delete the matched lines header

 *D-    DEL#=  1      N-REF#=000014 O-REF#=000015

 Recommended: decide if the deleted lines are needed or not,
 delete them as appropriate, then delete the control line.
./ ADD NAME=DMSTATS  0100-02273-02273-0938-00030-00030-00000-GARDINR
ISPF stats

  ISPF stats can be viewed and modified. If you want to check
  whether a member exists, use the prefix command ST next to the
  member you want to check. If the member exists, a display will
  be given of the member's ISPF statistics like this:

  -------------------------------- Member stats -------
   Command ===>

                          member   FRED
                         library   USER01.QUAL.WHATEVER

                  Version number   01
              Modification level   08
                   Creation date   94/04/08
              Last changed  date   95/09/29
              Last changed  time   16:31
       Current number of records   48
     Beginning number of records   32
       Number of changed records   0
                          Userid   USER01

     Use command UPDATE to reset statistics

  You can change any of the statistics at this point. Type UPDATE
  on the command line, and all the displayed stats will turn from
  blue to green. Simply overtype with the values you want. You
  must have security access (RACF or ACF2 or whatever you are
  using) to the dataset for this to work properly.
./ ADD NAME=DMVERS   0100-02273-02273-0938-00073-00073-00000-GARDINR
Member find

  You can search for any number of occurrences of a member in
  your DDF list. This is controlled by the Type field. The Type
  field on the display contains text determined by the user that
  indicates what type of data is contained in the dataset. You
  might choose CBL for COBOL programs, or JCL for JCL, or PLI for
  PL/1 programs, and so on.

  DDF 1.0 ------------- USERID1 Jun 1994 -------  ROW 1 FROM nnn
  Command ===>                                 Scroll ===> PAGE
  Show list > ABC                                              <
  Cmd  Member   Text                     Description   Show Type
       FRED     PROJ1.QUAL2.QUAL3.QUAL4                ABC   A
                PROJ1.LEVEL2.QUAL3.QUAL4               ABC   A
                PROJ2.QUAL2.QUAL3.QUAL4                ABC   A
       BILL     OTHERID.SOME.DATA.OR.OTHER             ABD   COB
                YET.ANOTHER.LEVEL                      P1    PLI
       XYZ      PROJ3.ANOTHER.DATSET                   RST   XX

  The format of Find is F <membername> <type> <exclusion specification>
  where

  F

  membername
       The member for which the search is to be made
  type
       The value under the Type column, indicating which datasets
       are to be checked. * means search all types
  exclusion specification
       x    search only the lines excluded from the display
       nx   search only the lines NOT exluded from the dispay
       *    search all lines, excluded or not

  Some examples of F commands might be:

    1. F FRED JCL NX
    2. F AAXXX01 COB NX
    3. F FRED R X
    4. F FRED * NX
    5. F FRED * *

  where

    1. Find the member FRED amongst datasets of type JCL that are
       not excluded from the display, i.e search amongst those
       datasets currently visible.
    2. Find the member AAXXX01 amongst datasets of type COB that
       are not excluded from the display
    3. Find the member FRED amongst datasets of type R that are
       excluded from the display
    4. Find the member FRED amongst all datasets that are
       currently visible.
    5. Find the member FRED amongst all datasets whether visible
       or excluded.

  The Find function will then show an abbreviated display, giving
  those datasets that have been searched. The rightmost portion
  of the screen is changed to show the ISPF stats for each member
  found. This means that:

     * it becomes possible easily to see what versions are extant
     * the last changed dates can be seen for each version found,
       along with the userid making the change

  Find is particularly useful in an environment where multiple
  parallel developments are being undertaken - the usual case in
  most large IT departments - because it can help track multiple
  versions and avoid regression (regression is where a software
  change or fixed is removed by a subsequent version because the
  developer of the second one did not incorporate all changes
  taking place in parallel).
./ ADD NAME=DSLIST   0100-02273-02273-0938-00058-00058-00000-GARDINR
Show

  When you first use DDF you will only have a half dozen or so
  datasets on your display. But as you get used to it, you will
  soon find that you have more than one screen's worth and you
  will be continuously scrolling up and down searching for the
  ones you want, which becomes irritating and time consuming. The
  Show heading allows you to of organise the display to group
  logically related datasets together and either show or exclude
  them from the display as you choose.For example:

  DDF 1.0 ------------- USERID1 Jun 1994 -------  ROW 1 FROM nnn
  Command ===>                                 Scroll ===>PAGE
  Show list >                                                 <
  Cmd  Member   Text                     Description   Show
       FRED     PROJ1.QUAL2.QUAL3.QUAL4                ABC
                PROJ1.LEVEL2.QUAL3.QUAL4               ABC
                PROJ2.QUAL2.QUAL3.QUAL4                ABC
       BILL     OTHERID.SOME.DATA.OR.OTHER             ABD
                YET.ANOTHER.LEVEL                      P1
       XYZ      PROJ3.ANOTHER.DATSET                   RST

  You can type anything under the Show heading to identify
  related datasets, as in the display above where all the ABC
  project's datasets are grouped together. There are no special
  values that you have to enter under Show; numbers and special
  characters are just as good as letters. The Show column
  determines the order that the datasets are shown; lines with
  blank Show field of always being at the top of the display. You
  can control the display with these commands: On the command
  line:

  H    Show the first line only in each group
  SORT
       Reorder the lines into the order given by the Show field
  RESET
       Reveal all lines

  Prefix commands (under the Cmd heading)

  HI   Suppress all following lines that have the same Show field
  SH   Reveal all following lines that have the same Show field

  If you hide a group of lines, then overtype the Show field on
  the first line, all the following hidden lines inherit the new
  Show value.

  You can thus quickly reorder the complete display:

     * Type H on the command line to show only the first line of
       each group
     * overtype each Show field with your new value
     * type Sort on the command line to reorder the list

  You can now use the SH and HI prefix commmands to show the
  individual lines in each group.

  See also Show list
./ ADD NAME=DSLIST2  0100-02273-02273-0938-00034-00034-00000-GARDINR
Show list

  The Show list is an alternative way of limiting the number of
  lines shown on the screen; if you have not already done so, you
  should read about Show before continuing here.

  Type a list of the groups you want to see next to the Show List
  heading All the lines in every group are shown, and no others.
  This feature, unlike using the SH and HI prefix commands, does
  not show the first line of each group; to restore the first
  lines, type H on the command line.

       There does not have to be a perfect match between the Show
  List and entries under the Show heading. In this example:

  DDF 1.0 ------------- USERID1 Jun 1994 -------  ROW 1 FROM nnn
  Command ===>                                 Scroll ===>PAGE
  Show list >                                                 <
  Cmd  Member   Text                     Description   Show
       FRED     PROJ1.QUAL2.QUAL3.QUAL4                ABC
                PROJ1.LEVEL2.QUAL3.QUAL4               ABC
                PROJ2.QUAL2.QUAL3.QUAL4                ABC
       BILL     OTHERID.SOME.DATA.OR.OTHER             ABD
                YET.ANOTHER.LEVEL                      P1
       XYZ      PROJ3.ANOTHER.DATSET                   RST

  if you had entered AB in the Show List above, then all lines
  with a show field starting AB would be shown, i.e. projects ABC
  and ABD..  This feature can be used to create groups and
  subgroups of datasets, entirely under your control.

        Note that if you enter a Show List value for which there
  are no matches, a new line will be created for you, so that the
  new Show group can be created.
./ ADD NAME=DSTART   0100-02273-02273-0938-00049-00049-00000-GARDINR
Getting started

 Assuming that installation is complete, start by typing

         TSO UTCDSM5

 on any ISPF command line; there will at first be no datasets in
 your list. To get some in quickly, use the Add command on the
 command line, of which there are two options:

     ADD <qualifier>
     ADD ALLOC

 If you typed     ADD userid01     DDF would select all datasets
 with that HLQ and you might see something like this:

 ------------------ Select from dataset prefix list ---  ROW 1 TO 20 OF 85
  Command ===>                                           Scroll ===> HALF

 Cmd          Dataset name                          Added?  Show    Type
              USERID01.QUAL021.XMDEC28                     >         >
              USERID01.QUAL02.CLIB                         >         >
              USERID01.CLIB                                >         >
              USERID01.DGIPROT.TABLE                       >         >

 Under Cmd you can now type S to select datasets to be added to
 the display. Don't worry at this stage about putting anything
 under the Show or Type headings. Use PF3 or END to go back to
 the DDF screen.

       To add lines from the datasets allocated to your session,
 type ADD ALLOC on the DDF command line. You will now see
 datasets of different HLQs allocated to your ISPF session.

 ----------------- Select from allocated data sets -- ROW 1 TO 20 OF 104
 Command ===>                                         Scroll ===> HALF

 Cmd DDname   Dataset name                          Added? Show     Type
     SYSHELP  SYS3.HELP                                   >         >
              SYS1.HELP                                   >         >
     SMPTABL  SYS4.TLIB                                   >         >
     SYS00001 SYS1.BRODCAST                               >         >
     ISPPROF  USERID01.ISPF.PROFILE                       >         >
     ISPTABL  USERID01.ISPF.PROFILE                       >         >
     ISPPLIB  SYS3.PLIB                                   >         >
              SYS1.PLIB                                   >         >

 Again use S in the prefix area to select datasets to add to the
 DDF display
./ ADD NAME=DTEMPL   0100-02273-02273-0938-00056-00056-00000-GARDINR
Templates

  Edit copy provides a way of bringing in a member name into the
  one you are editing. This saves typing by using pre-written
  outlines of commonly used code. The copy process is, however,
  not as neat as we would like if you want to copy from a dataset
  other than the one being edited; you have to type Copy, then
  the name of the dataset, and then select the member you want.
  It's only if the member you want is in the dataset you happen
  to be editing that you can type

         COPY membername

  on the command line. With DDF you can sometimes code it this
  way even if what you want is on a different dataset.

  This is best illustrated by a walk-through of what an
  experienced DDF user might do and what they would see on the
  way. On the DDF command line, our expert types TEMPL to show
  the separate datasets (TEMPLATES) used to hold Rexx, JCL, etc
  fragments. These datasets are under our expert's control.

  C Dataset name                          DDF type
     <hlq>.TEMPLATE.JCL               J
     <hlq>.TEMPLATE.REXX              R
     <hlq>.TEMPLATE.CLIST             C

  I (insert) D (delete) R (repeat) prefix commands are used to
  control the list. <hlq> is the high-level qualifer for your
  code fragment datasets. Note that the word TEMPLATE is not
  required but it might be useful as a standard. The DDF screen
  looks like this:

  Show list > ABC                                              <
  Cmd  Member   Text                     Description   Show Type
       FRED     PROJ1.QUAL2.QUAL3.QUAL4                ABC   J
                PROJ1.LEVEL2.QUAL3.QUAL4               ABC   R

  When fred is edited, DDF will see it's Type J, which is
  associated with a dataset called <hlq>.TEMPLATE.JCL, The
  template dataset will be concatenated after the dataset being
  edited. This means that during the edit of FRED our expert
  could type (for example) COPY JOBCARD and Edit will attempt to
  get it either from the dataset being edited or the template.
  The point is that all datasets given type J will have the
  template dataset concatentated in this way, enabling the
  simplifed DDF copy feature for any number of datasets

  On taking a DDF member list of PROJ1.QUAL2.QUAL3.QUAL4 above,
  the template dataset will again be concatentated, giving a list
  of the combined members of the two datasets. For this reason
  it's probably best to give all template members names beginning
  with Z; this will ensure that they sort to the end of the list.
  Note that you will be able to distinguish between members on
  the main and template dataset by their level numbers (1 and 2,
  respectively).
./ ADD NAME=D3N      0100-02273-02273-0938-00069-00069-00000-GARDINR
ISPF 3.n operations

  You can invoke ISPF options 3.1, 3.2, 3.3, 3.4, 3.6 and 3.14
  under the CMD heading as shown here using 3.1 as an example.

  Cmd Member   Text                     Description   Show
  3.1 FRED     USERID.QUAL2.QUAL3.QUAL4
  31  BILL     OTHERID.SOME.DATA.OR.OTHER

  You can always omit the dot, as shown here on the second line.
  DDF does not implement 3.5 (reset ISPF stats) or 3.12 (SuperC
  compare) because both of these are implemented in a different
  way within DDF(ST prefix command and the CPN/CPO prefix
  commands, respectively).

        In each case DDF will show the appropriate 3.n screen
  with the dataset name field filled in, ready for action. You
  can then carry on as if in normal ISPF, except that of course
  you will not have to type in the names. 3.1, 3.2, 3.6 and 3.14
  need no further explanation, but 3.3 and 3.4 need a bit more
  information.

  3.3

  You use 3.3 in conjunction with TO or OV, like the single
  member moves. You do not get the first (copy from) 3.3 screen
  until both 3.3 and (one of) TO or OV has been entered:

  Cmd Member   Text                     Description   Show
  3.3 FRED     USERID.QUAL2.QUAL3.QUAL4
  to  BILL     OTHERID.SOME.DATA.OR.OTHER

  When it is shown, the copy from dataset name will have been
  filled in and you can then select members for copy or move in
  the normal 3.3 style. When you press enter, the 3.3 copy to
  screen will be displayed, again with the to dataset name filled
  in. The member name FRED will be used as a pattern.

  3.4

  You can select how many qualifiers you want 3.4 to use, like
  this:

  Cmd  Member   Text                     Description   Show
       FRED     USERID.QUAL2.QUAL3.QUAL4
  34 2 BILL     OTHERID.SOME.DATA.OR.OTHER
  34 * BILL     OTHERID.SOME.DATA.OR
  34   BILL     OTHERID.SOME.DATA.OR*

  The 3.4 (or 34 as shown here - you can always omit the dots)
  will give a dataset list using two qualifiers OTHERID.SOME. If
  you just specify 34 without a number, the whole line will be
  used as the qualifier.  Note that the member name is ignored in
  this operation.

        34 * will cause the line to be used a pattern rather than
  a qualifier, like this

  34 *          OTHERID.SOME.DATA.OR

       shows    OTHERID.SOME.DATA.OR.OTHER
       and      OTHERID.SOME.DATA.ORWHAT

  34            OTHERID.SOME.DATA.OR
       shows
       only     OTHERID.SOME.DATA.OR.OTHER

  You can put an * on the end of the line, as illustrated, to get
  the same effect, in which case the * will remain on the line.
./ ADD NAME=RGCONT   0100-02273-02273-0938-00012-00012-00000-GARDINR
        Roy Gardiner
        64 High Road
      Buckhurst Hill
       Essex IG9 5RW

    044 20 8504 8267

        In an attempt to reduce spam, I have stoped using
    'mailto' in my HTML and encode my email address to be obvious
    only to real readers:

          gardiner at-sign btinternet dot com
